import cocoa.*;
import cocoa.qtkit.*;
import random.*;
import sqlite.*;
import Vinyl.library.*;
import Vinyl.library.datasources.*;
import libc;

record StoppedState ();

enum PlaylistMode { Playing, Paused }

variant TrackOrder = Vector[SizeT] | Range[SizeT];

overload index(o: TrackOrder, n) = match(o,
    Vector[SizeT], vec => vec[n],
    Range[SizeT],  ran => ran[n],
);

sequentialTrackOrder(trackCount)
    = TrackOrder(range(trackCount));

[S | LValueSequence?(S) and RandomAccessSequence?(S) and SizedSequence?(S)]
private _shuffleTrackOrder(s: S, trackNumber) {
    for (i in reverseRange(size(s))) {
        var j = libc.random() % (i+1);
        swap(s[i], s[j]);
        if (j == trackNumber)
            trackNumber = i;
        else if (i == trackNumber)
            trackNumber = j;
    }
}

shuffledTrackOrder(trackCount, trackNumber_) {
    var trackNumber = trackNumber_;
    var order = Vector[SizeT](range(trackCount));
    _shuffleTrackOrder(order, trackNumber);
    // always put the current track first
    if (trackNumber != 0)
        swap(order[trackNumber], order[0]);

    return TrackOrder(move(order));
}

overload shuffledTrackOrder(trackCount) {
    var order = Vector[SizeT](range(trackCount));
    _shuffleTrackOrder(order, 0);

    return TrackOrder(move(order));
}


record PlaylistState (
    mode: PlaylistMode,
    trackOrder: TrackOrder,
    trackNumber: SizeT,
    library: Pointer[Library],
    libraryView: LibraryView,
    movie: Retained[QTMovie],
    tracks: Vector[PlaylistTrack],
);

[I | Integer?(I)]
overload PlaylistState(mode: PlaylistMode, trackId: I, library: Pointer[Library], view: LibraryView, shuffle?: Bool)
{
    var returned = PlaylistState(
        mode,
        sequentialTrackOrder(SizeT(0)),
        SizeT(),
        library,
        view,
        Retained[QTMovie](),
        Vector[PlaylistTrack]()
    );

    _changeLibraryView(returned, view, trackId, shuffle?);

    return move(returned);
}

setSequentialTrackOrder(ps: PlaylistState) {
    ps.trackNumber = ps.trackOrder[ps.trackNumber];
    ps.trackOrder = sequentialTrackOrder(size(ps.tracks));
}

setShuffledTrackOrder(ps: PlaylistState) {
    var realTrackNumber = ps.trackOrder[ps.trackNumber];
    ps.trackOrder = shuffledTrackOrder(size(ps.tracks), realTrackNumber);
    ps.trackNumber = 0;
}

changeLibraryView(ps: PlaylistState, view: LibraryView) {
    var realTrackNumber = ps.trackOrder[ps.trackNumber];
    var trackId = ps.tracks[realTrackNumber].track_id;
    var shuffle? = variantIs?(ps.trackOrder, Vector[SizeT]);
    ps.libraryView = view;
    return _changeLibraryView(ps, view, trackId, shuffle?);
}

_changeLibraryView(ps: PlaylistState, view: LibraryView, trackId: NSInteger, shuffle?: Bool) {
    var i = SizeT(0);
    var currentTrack? = false;
    clear(ps.tracks);
    ps.trackNumber = 0;
    for (row in libraryViewStatement(ps.library^.db, String(), view)) {
        var track = rowRecord(row, PlaylistTrack);
        push(ps.tracks, track);
        if (track.track_id == trackId) {
            ps.trackNumber = i;
            currentTrack? = true;
        }
        inc(i);
    }

    if (shuffle?) {
        ps.trackOrder = shuffledTrackOrder(i, ps.trackNumber);
        ps.trackNumber = 0;
    } else
        ps.trackOrder = sequentialTrackOrder(i);
    return currentTrack?;
}

variant PlayerState = StoppedState | PlaylistState;

overload selector(static #"state") = PlayerState;
overload selector(static #"setState:") = Void, PlayerState;
overload selector(static #"handleMovieDidEndNotification:") = Void, NSNotification;
overload selector(static #"handleMovieLoadStateDidChangeNotification:") = Void, NSNotification;
overload selector(static #"handleMovieTimeDidChangeNotification:") = Void, NSNotification;
overload selector(static #"playLibrary:view:trackId:") = Void, Pointer[Library], LibraryView, NSInteger;
overload selector(static #"changeView:") = Void, LibraryView;
overload selector(static #"resume") = Void;
overload selector(static #"pause") = Void;
overload selector(static #"stop") = Void;
overload selector(static #"previousTrack") = Void;
overload selector(static #"nextTrack") = Void;
overload selector(static #"shuffle") = Bool;
overload selector(static #"setShuffle:") = Void, Bool;
overload selector(static #"repeatMode") = RepeatMode;
overload selector(static #"setRepeatMode:") = Void, RepeatMode;
overload selector(static #"playerState") = Pointer[PlayerState];
overload selector(static #"currentTrack") = Pointer[PlaylistTrack];
overload selector(static #"currentTrackNumber") = NSInteger;
overload selector(static #"setCurrentTrackTime:") = Void, NSTimeInterval;
overload selector(static #"currentTrackTime") = NSTimeInterval;
overload selector(static #"updateTimeTimer:") = Void, NSTimer;

enum RepeatMode { NoRepeat, RepeatAll, RepeatOne }

alias PlayerStateDidChangeNotification = NSString(#"VinylPlayerStateDidChangeNotification");
alias PlayerUpdateTimeNotification = NSString(#"VinylPlayerUpdateTimeNotification");

alias UPDATE_TIME_INTERVAL = 0.5;

startUpdateTimeTimer(self: Player) {
    if (nil?(self^.updateTimeTimer)) {
        self^.updateTimeTimer = NSTimer.timerWithTimeInterval_target_selector_userInfo_repeats(
            UPDATE_TIME_INTERVAL,
            self,
            selectorHandle(#"updateTimeTimer:"),
            nil(),
            true,
        );
        NSRunLoop.currentRunLoop().addTimer_forMode(
            self^.updateTimeTimer,
            NSDefaultRunLoopMode,
        );
    }
}
stopUpdateTimeTimer(self: Player) {
    self^.updateTimeTimer.invalidate();
    self^.updateTimeTimer = nil();
}

record Player = newClass(NSObject,
    InstanceVars(
        state: PlayerState,
        volume: Float,
        shuffle: Bool,
        repeatMode: RepeatMode,
        updateTimeTimer: Retained[NSTimer],
    ),
    ClassMethods(),
    InstanceMethods(
        (#"init", self => initObjectWith(self, #"init", self => {
            self^.state <-- PlayerState(StoppedState());
            self^.volume = 1.0f;
            self^.shuffle = false;
            self^.repeatMode = NoRepeat;

            NSNotificationCenter.defaultCenter().addObserver_selector_name_object(
                self,
                selectorHandle(#"handleMovieDidEndNotification:"),
                QTMovieDidEndNotification,
                nil()
            );
            NSNotificationCenter.defaultCenter().addObserver_selector_name_object(
                self,
                selectorHandle(#"handleMovieLoadStateDidChangeNotification:"),
                QTMovieLoadStateDidChangeNotification,
                nil()
            );
            NSNotificationCenter.defaultCenter().addObserver_selector_name_object(
                self,
                selectorHandle(#"handleMovieTimeDidChangeNotification:"),
                QTMovieTimeDidChangeNotification,
                nil()
            );
            return self;
        })),
        DeallocInstanceMethod(),
        ...PropertyInstanceMethods(#state, PlayerState),

        (#"handleMovieDidEndNotification:", (self, notification) => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    if (is?(playlistState.movie, notification.object())) {
                        if (self^.repeatMode == RepeatOne) {
                            playlistState.movie.stop();
                            playlistState.movie = nil();
                            self.resume();
                        } else
                            self.nextTrack();
                    }
                }
            );
        }),
        (#"handleMovieLoadStateDidChangeNotification:", (self, notification) => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    if (is?(playlistState.movie, notification.object())
                        and playlistState.movie.attributeForKey(QTMovieLoadStateAttribute)
                            == QTMovieLoadStateError
                    ) {
                        if (self^.repeatMode == RepeatOne)
                            self.stop();
                        else
                            self.nextTrack();
                    }
                }
            );
        }),
        (#"handleMovieTimeDidChangeNotification:", (self, notification) => {
            NSNotificationCenter.defaultCenter().postNotificationName_object(
                PlayerUpdateTimeNotification, self
            );
        }),

        (#"updateTimeTimer:", (self, timer) => {
            NSNotificationCenter.defaultCenter().postNotificationName_object(
                PlayerUpdateTimeNotification, self
            );
        }),

        (#"playLibrary:view:trackId:", (self, library, libraryView, trackId) => {
            self.stop();
            self^.state = PlayerState(
                PlaylistState(Paused, trackId, library, libraryView, self^.shuffle)
            );
            self.resume();
        }),

        (#"changeView:", (self, libraryView) => {
            match(self^.state,
                StoppedState,  stopped => {},
                PlaylistState, playlistState => {
                    var currentTrack? = changeLibraryView(playlistState, libraryView);
                    if (not currentTrack?)
                        self.stop();
                },
            );
        }),

        (#"resume", self => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    if (playlistState.trackNumber < size(playlistState.tracks)) {
                        var realTrackNumber = playlistState.trackOrder[playlistState.trackNumber];
                        if (nil?(playlistState.movie))
                            playlistState.movie = movieForFileName(
                                self,
                                playlistState.tracks[realTrackNumber].filename
                            );
                        playlistState.movie.autoplay();
                        playlistState.mode = Playing;
                        NSNotificationCenter.defaultCenter().postNotificationName_object(
                            PlayerStateDidChangeNotification, self
                        );
                        startUpdateTimeTimer(self);
                    } else
                        self.stop();
                }
            );
        }),

        (#"pause", self => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    playlistState.movie.stop();
                    playlistState.mode = Paused;
                    NSNotificationCenter.defaultCenter().postNotificationName_object(
                        PlayerStateDidChangeNotification, self
                    );
                    stopUpdateTimeTimer(self);
                }
            );
        }),

        (#"stop", self => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    playlistState.movie.stop();
                    self^.state = PlayerState(StoppedState());
                    NSNotificationCenter.defaultCenter().postNotificationName_object(
                        PlayerStateDidChangeNotification, self
                    );
                    stopUpdateTimeTimer(self);
                }
            );
        }),

        (#"previousTrack", self => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    var currentTime = playlistState.movie.currentTime();
                    if (currentTime.timeValue < currentTime.timeScale * 2) {
                        // in the first two seconds? then jump back a track
                        playlistState.movie.stop();
                        playlistState.movie = nil();
                        if (playlistState.trackNumber > 0) {
                            playlistState.trackNumber -= 1;
                            self.resume();
                        } else if (self^.repeatMode == RepeatAll) {
                            playlistState.trackNumber = size(playlistState.tracks) - 1;
                            self.resume();
                        } else
                            self.stop();
                    } else {
                        // else restart from the beginning
                        self.setCurrentTrackTime(0.0);
                    }
                }
            );
        }),

        (#"nextTrack", self => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    playlistState.movie.stop();
                    playlistState.movie = nil();
                    if (playlistState.trackNumber < size(playlistState.tracks) - 1) {
                        playlistState.trackNumber += 1;
                        self.resume();
                    } else if (self^.repeatMode == RepeatAll) {
                        playlistState.trackNumber = 0;
                        self.resume();
                    } else
                        self.stop();
                }
            );
        }),

        (#"setCurrentTrackTime:", (self, time) => {
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    // XXX using NSInvocation to hack around x86-64 abi bugs
                    var invocation = NSInvocation.invocationWithMethodSignature(
                        playlistState.movie.methodSignatureForSelector(
                            selectorHandle(#"setCurrentTime:")
                        )
                    );
                    invocation.setTarget(playlistState.movie);
                    invocation.setSelector(selectorHandle(#"setCurrentTime:"));
                    var qttime = QTMakeTime(CLong(time * 1000.0), CLong(1000));
                    invocation.setArgument_atIndex(RawPointer(&qttime), NSInteger(2));
                    invocation.invoke();
                }
            );
        }),

        (#"currentTrackTime", self => match(self^.state,
            StoppedState,  stopped => 0.0,
            PlaylistState, playlistState => {
                var invocation = NSInvocation.invocationWithMethodSignature(
                    playlistState.movie.methodSignatureForSelector(
                        selectorHandle(#"currentTime")
                    )
                );
                invocation.setTarget(playlistState.movie);
                invocation.setSelector(selectorHandle(#"currentTime"));
                invocation.invoke();
                var qttime = QTTime();
                invocation.getReturnValue(RawPointer(&qttime));
                return Double(qttime.timeValue)/Double(qttime.timeScale);
            }
        )),

        ReaderInstanceMethod(#volume, Float),
        
        (#"setVolume:", (self, volume) => {
            self^.volume = volume;
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    if (not nil?(playlistState.movie))
                        playlistState.movie.setVolume(Float(volume));
                }
            );
        }),

        ReaderInstanceMethod(#shuffle, Bool),
        (#"setShuffle:", (self, shuffle) => {
            self^.shuffle = shuffle;
            match(self^.state,
                StoppedState,  stopped => { },
                PlaylistState, playlistState => {
                    var trackNumber = playlistState.trackOrder[playlistState.trackNumber];
                    if (shuffle)
                        setShuffledTrackOrder(playlistState);
                    else
                        setSequentialTrackOrder(playlistState);
                }
            );
        }),

        ...PropertyInstanceMethods(#repeatMode, RepeatMode),

        (#"playerState", self => &self^.state),

        (#"currentTrack", self => match(self^.state,
            StoppedState,  stopped       => null(PlaylistTrack),
            PlaylistState, playlistState => {
                var realTrackNumber = playlistState.trackOrder[playlistState.trackNumber];
                return &playlistState.tracks[realTrackNumber];
            },
        )),

        (#"currentTrackNumber", self => match(self^.state,
            StoppedState,  stopped       => NSInteger(-1),
            PlaylistState, playlistState => NSInteger(playlistState.trackOrder[playlistState.trackNumber]),
        ))
    ),
);

record QTMovieError (error: NSError);
instance Exception = QTMovieError;

movieForFileName(self, name) {
    var error = nil(NSError);
    
    var movie = QTMovie.movieWithAttributes_error(makeNSDictionary(
        QTMovieOpenForPlaybackAttribute, true,
        QTMovieFileNameAttribute, name,
    ), &error);

    if (nil?(movie))
        throw QTMovieError(error);

    movie.setVolume(self^.volume);

    return movie;
}
