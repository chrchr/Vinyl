import cocoa.*;
import cocoa.appkit.*;
import sqlite.*;
import maybe.*;
import Vinyl.library.*;
import Vinyl.controls.deletingtableview.*;
import Vinyl.formatting.*;
import Vinyl.qtplayer.*;


//
// data source for library outline view
//

overload selector(static #"initWithLibrary:") = Id, Pointer[Library];
overload selector(static #"insertPlaylistWithName:parentItem:")
    = Id, NSString, Id;
overload selector(static #"insertPlaylistFolderWithName:")
    = Id, NSString;

libraryDataSourceItemCount(self: LibraryDataSource)
    = NSInteger(
        1 // Library
        + self^.folders.count() // folders
        + self^.playlists.count() // toplevel playlists
    );

record LibraryDataSource = newClass(NSObject,
    InstanceVars(
        (#library, Pointer[Library]),
        (#folders, Retained[NSMutableArray]),
        (#playlists, Retained[NSMutableArray]),
    ),
    ClassMethods(
    ),
    InstanceMethods(
        (#"initWithLibrary:", (self, library) => initObjectWith(self, #"init", self => {
            self^.library = library;
            self^.folders = NSMutableArray.array();
            self^.playlists = NSMutableArray.array();
            refreshLibraryDataSource(self);
            return self;
        })),
        DeallocInstanceMethod(),
        (#"outlineView:numberOfChildrenOfItem:", (self, outlineView, item) =>
            if (nil?(item))
                libraryDataSourceItemCount(self)
            else if (itemIsFolder?(item))
                NSInteger(item["playlists"].count()) // playlist folder
            else
                NSInteger(0) // library or playlist, no children
        ),
        (#"outlineView:isItemExpandable:", (self, outlineView, item) => itemIsFolder?(item)),
        (#"outlineView:child:ofItem:", (self, outlineView, index, item) => {
            if (nil?(item)) {
                if (index == 0)
                    return Id(NSString(#"Library"));
                else {
                    var numFolders = self^.folders.count();
                    if (index - 1 < numFolders)
                        return self^.folders[index - 1];
                    else
                        return self^.playlists[index - numFolders - 1];
                }
            } else
                return item["playlists"][index];
        }),
        (#"outlineView:objectValueForTableColumn:byItem:", (self, outlineView, column, item) => {
            if (item.isKindOfClass(NSString))
                return item;
            else
                return item["name"];
        }),
        (#"outlineView:persistentObjectForItem:", (self, outlineView, item) => {
            if (itemIsFolder?(item))
                return item["id"];
            else
                return nil(Id);
        }),
        (#"outlineView:itemForPersistentObject:", (self, outlineView, object) => {
            println(object);
            if (object.isKindOfClass(NSNumber)) {
                for (folder in self^.folders)
                    if (folder["id"] == object)
                        return folder;
            }
            return nil(Id);
        }),
        (#"outlineView:setObjectValue:forTableColumn:byItem:", (self, outlineView, value, column, item) => {
            if (item.isKindOfClass(NSString))
                return;
            else if (value.description().length() == 0)
                return;
            else {
                item.setObject_forKey(value.description(), "name");
                if (itemIsFolder?(item))
                    updateLibraryFolderName(self^.library^, Int(item["id"]), String(value));
                else
                    updateLibraryPlaylistName(self^.library^, Int(item["id"]), String(value));
            }
        }),
        (#"outlineView:deleteItem:", (self, outlineView, item) => {
            if (item.isKindOfClass(NSString))
                return;
            var parentItem = outlineView.parentForItem(item);

            if (itemIsFolder?(item)) {
                deleteLibraryFolder(self^.library^, Int(item["id"]));
                self^.folders.removeObject(item);
            } else {
                deleteLibraryPlaylist(self^.library^, Int(item["id"]));
                self^.playlists.removeObject(item);
                for (folder in self^.folders)
                    folder["playlists"].removeObject(item);
            }

            outlineView.reloadData();
            if (nil?(parentItem))
                outlineView.selectRowIndexes_byExtendingSelection(
                    NSIndexSet.indexSetWithIndex(NSUInteger(0)),
                    false
                );
            else {
                var parentRow = outlineView.rowForItem(parentItem);
                outlineView.selectRowIndexes_byExtendingSelection(
                    NSIndexSet.indexSetWithIndex(NSUInteger(parentRow)),
                    false
                );
            }
        }),

        (#"outlineView:writeItems:toPasteboard:", (self, outlineView, items, pasteboard) => {
            if (items.count() != 1)
                return false;
            var item = items[0];
            if (not itemIsPlaylist?(item))
                return false;

            outlineView.setDraggingSourceOperationMask_forLocal(
                NSUInteger(bitwiseOr(NSDragOperationMove, NSDragOperationDelete)),
                false,
            );

            pasteboard.declareTypes_owner(
                makeNSArray(PlaylistIdsPboardType),
                self
            );
            pasteboard.setPropertyList_forType(makeNSArray(item["id"]), PlaylistIdsPboardType);

            return true;
        }),

        (#"outlineView:validateDrop:proposedItem:proposedChildIndex:", (self, outlineView, info, item, index) => {
            if (item.isKindOfClass(NSString))
                return NSDragOperation(NSDragOperationNone);

            var pasteboard = info.draggingPasteboard();
            var pasteboardType = pasteboard.availableTypeFromArray(
                makeNSArray(TrackIdsPboardType, PlaylistIdsPboardType)
            );
            if (nil?(pasteboardType))
                return NSDragOperation(NSDragOperationNone);

            if (nil?(item))
                outlineView.setDropItem_dropChildIndex(
                    nil(),
                    NSInteger(-1)
                );
            else if (itemIsFolder?(item))
                outlineView.setDropItem_dropChildIndex(
                    item,
                    NSInteger(item["playlists"].count())
                );
            else if (itemIsPlaylist?(item) and pasteboardType == PlaylistIdsPboardType)
                return NSDragOperation(NSDragOperationNone);

            return NSDragOperation(NSDragOperationCopy);
        }),

        (#"outlineView:acceptDrop:item:childIndex:", (self, outlineView, info, item, index) => {
            if (item.isKindOfClass(NSString))
                return false;

            var pasteboard = info.draggingPasteboard();
            var pasteboardType = pasteboard.availableTypeFromArray(
                makeNSArray(TrackIdsPboardType, PlaylistIdsPboardType)
            );
            if (nil?(pasteboardType))
                return false;

            var playlistItem = nil();
            var newPlaylist? = false;
            if (pasteboardType == TrackIdsPboardType) {
                if (itemIsPlaylist?(item))
                    playlistItem = item;
                else {
                    playlistItem = self.insertPlaylistWithName_parentItem(
                        #"New Playlist", // XXX derive playlist name from track attributes
                        item
                    );
                    newPlaylist? = true;
                }

                var trackIds = NSArray(pasteboard.propertyListForType(pasteboardType));
                insertLibraryPlaylistTracks(self^.library^, NSInteger(playlistItem["id"]), mapped(NSInteger, trackIds));
            } else if (pasteboardType == PlaylistIdsPboardType) {
                var playlistId = NSInteger(pasteboard.propertyListForType(pasteboardType)[0]);
                var parentFolderId = if (itemIsFolder?(item))
                    Maybe(NSInteger(item["id"]))
                else
                    nothing(NSInteger);

                for (folder in self^.folders)
                    for (playlist in folder["playlists"])
                        if (playlist["id"] == playlistId) {
                            if (parentFolderId == Maybe(NSInteger(folder["id"])))
                                return false;
                            playlistItem = playlist;
                            folder["playlists"].removeObject(playlist);
                            goto foundPlaylistItem;
                        }
                for (playlist in self^.playlists)
                    if (playlist["id"] == playlistId) {
                        if (parentFolderId == nothing(NSInteger))
                            return false;
                        playlistItem = playlist;
                        self^.playlists.removeObject(playlist);
                        goto foundPlaylistItem;
                    }
foundPlaylistItem:
                moveLibraryPlaylist(self^.library^, playlistId, parentFolderId);
                if (itemIsFolder?(item) and not nil?(playlistItem))
                    item["playlists"].addObject(playlistItem);
                else
                    self^.playlists.addObject(playlistItem);
            } else
                return false;

            outlineView.reloadData();
            if (itemIsFolder?(item))
                outlineView.expandItem(item);

            var playlistRow = outlineView.rowForItem(playlistItem);
            outlineView.selectRowIndexes_byExtendingSelection(
                NSIndexSet.indexSetWithIndex(NSUInteger(playlistRow)),
                false
            );
            if (newPlaylist?)
                outlineView.editColumn_row_withEvent_select(
                    NSInteger(0),
                    NSInteger(playlistRow),
                    nil(NSEvent),
                    true
                );

            return true;
        }),

        (#"insertPlaylistWithName:parentItem:", (self, name, parentItem) => {
            var parentId = if (itemIsFolder?(parentItem))
                Maybe(NSInteger(parentItem["id"]))
            else
                nothing(NSInteger);

            var id = insertLibraryPlaylist(self^.library^, String(name), parentId);

            var newItem = makeNSMutableDictionary("id", id, "name", name);

            if (itemIsFolder?(parentItem))
                parentItem["playlists"].addObject(newItem);
            else
                self^.playlists.addObject(newItem);

            return newItem;
        }),
        (#"insertPlaylistFolderWithName:", (self, name) => {
            var id = insertLibraryPlaylistFolder(self^.library^, String(name));

            var newItem = makeNSMutableDictionary(
                "id", id,
                "name", name,
                "playlists", makeNSMutableArray(),
            );

            self^.folders.addObject(newItem);

            return newItem;
        }),
    ),
);

refreshLibraryDataSource(self: LibraryDataSource) {
    self^.folders.removeAllObjects();
    self^.playlists.removeAllObjects();

    var folderPositions = HashMap[NSUInteger, NSUInteger]();

    for (row in SqliteStatement(self^.library^.db,
        "select playlist_folder_id, name from playlist_folders order by position"
    )) {
        folderPositions[row[0, NSUInteger]] = size(self^.folders);
        self^.folders.addObject(makeNSMutableDictionary(
            "id", row[0, Int],
            "name", row[1],
            "playlists", NSMutableArray.array()
        ));
    }

    for (row in SqliteStatement(self^.library^.db,
        "select playlist_id, name, playlist_folder_id from playlists
            order by playlist_folder_id, position"
    )) {
        var folder = nil(NSMutableArray);

        if (nullColumn?(row, 2)) {
            folder = self^.playlists;
        } else {
            var folderPosition = folderPositions[row[2, NSUInteger]];
            folder = self^.folders[folderPosition]["playlists"];
        }

        folder.addObject(makeNSMutableDictionary(
            "id", row[0, Int],
            "name", row[1]
        ));
    }
}

itemIsPlaylist?(item) = item.isKindOfClass(NSDictionary) and nil?(item["playlists"]);
itemIsFolder?(item) = item.isKindOfClass(NSDictionary) and not nil?(item["playlists"]);

private desc?(ascending?) = if (ascending?) "" else " desc";

sortSQL(sortColumn: String, ascending?: Bool) {
    var desc = desc?(ascending?);
    switch (sortColumn) {
    case "filename":
    case "name":
    case "sort_name":
        return "lower(tracks.sort_name)" + desc;
    case "album_name":
    case "album_sort_name":
    case "track_number":
    case "album_artist_name":
    case "album_artist_sort_name":
    case "album_compilation_p":
    case "side_number":
    case "sides_count":
    case "track_number":
    case "tracks_count":
        return printString(
            "not albums.compilation_p", desc,
            ", lower(coalesce(album_artists.sort_name, track_artists.sort_name))", desc,
            ", lower(albums.sort_name)", desc,
            ", tracks.side_number", desc,
            ", tracks.track_number", desc,
        );
    case "track_artist_name":
    case "track_artist_sort_name":
        return "lower(coalesce(track_artists.sort_name, album_artists.sort_name))" + desc;
    case "genre_name":
        return "lower(genres.name)" + desc;
    case "composer_name":
    case "composer_sort_name":
        return "lower(composers.sort_name)" + desc;
    case "grouping_name":
        return "lower(groupings.name)" + desc;
    case "duration_time":
        return "tracks.duration_time" + desc;
    case "year":
        return "cast(tracks.year as integer)" + desc;
    case "comments":
        return "tracks.comments" + desc;
    case "enabled_p":
        return "not enabled_p" + desc;
    case "play_count":
        return "track_options.play_count" + desc;
    case "added_date":
        return "track_options.added_date" + desc;
    case "modified_date":
        return "track_options.modified_date" + desc;
    case "played_date":
        return "track_options.played_date" + desc;
    case "track_id":
        return "tracks.track_id" + desc;

    default:
        return "tracks.track_id" + desc;
    }
}
record PlaylistFolderView (id: Int);
record PlaylistView (id: Int);
record SortedView (sort: String);
variant LibraryView = PlaylistFolderView | PlaylistView | SortedView;

[S | String?(S) and S != String]
overload SortedView(sort: S) = SortedView(String(sort));
overload SortedView() = SortedView(sortSQL(String("name"), true));

[O | ObjectRef?(O)]
overload SortedView(sortDescriptors: O) {
    var key = String("name");
    var ascending? = true;
    if (sortDescriptors.count() > 0) {
        var mainDescriptor = sortDescriptors[0];
        key = String(mainDescriptor.key());
        ascending? = mainDescriptor.ascending();
    }
    return SortedView(sortSQL(key, ascending?));
}

overload LibraryView() = LibraryView(SortedView());

record PlaylistTrack (
    track_id: NSInteger,
    filename: String,
    name: String,
    sort_name: Maybe[String],
    album_name: Maybe[String],
    album_sort_name: Maybe[String],
    album_artist_name: Maybe[String],
    album_artist_sort_name: Maybe[String],
    album_compilation_p: Bool,
    track_artist_name: Maybe[String],
    track_artist_sort_name: Maybe[String],
    genre_name: Maybe[String],
    composer_name: Maybe[String],
    composer_sort_name: Maybe[String],
    grouping_name: Maybe[String],
    side_number: Maybe[Int],
    sides_count: Maybe[Int],
    track_number: Maybe[Int],
    tracks_count: Maybe[Int],
    duration_time: NSTimeInterval,
    year: Maybe[String],
    comments: Maybe[String],
    enabled_p: Bool,
    play_count: Maybe[Int],
    added_date: Maybe[Int],
    modified_date: Maybe[Int],
    played_date: Maybe[Int]
);

overload PlaylistTrack() = PlaylistTrack(
    NSInteger(0),
    String(),
    String(),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    false,
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[Int](),
    Maybe[Int](),
    Maybe[Int](),
    Maybe[Int](),
    0.0,
    Maybe[String](),
    Maybe[String](),
    true,
    Maybe[Int](),
    Maybe[Int](),
    Maybe[Int](),
    Maybe[Int](),
);

record NoFieldForString (type: StringConstant, string: String);
instance Exception = NoFieldForString;

[R | Record?(R)]
fieldByName(forward r: R, fn, str) {
    static for (fieldName in ...mapValues(x => x.0, ...RecordFields(R))) {
        if (str == StaticName(fieldName))
            return forward fn(fieldRef(r, fieldName));
    }
    throw NoFieldForString(StaticName(R), String(str));
}

formattedCount(fn, number, count) {
    if (nothing?(count))
        return fn(number);
    else if (just?(number) and just?(count))
        return fn(printString(number, " of ", count));
    else
        return fn(nothing(Type(number)));
}

formattedFieldByName(r, fn, str) {
    switch (str) {
    case "track_number":
        return formattedCount(fn, r.track_number, r.tracks_count);
    case "side_number":
        return formattedCount(fn, r.side_number, r.sides_count);
    case "duration_time":
        return Id(timeFormat(r.duration_time));
    case "added_date":
        return Id(dateFormat(*r.added_date));
    case "modified_date":
        return Id(dateFormat(*r.modified_date));
    case "played_date":
        return Id(dateFormat(*r.played_date));
    default:
        return fieldByName(r, fn, str);
    }
}

overload selector(static #"initWithLibrary:sortDescriptors:") = Void, Pointer[Library], NSArray;
overload selector(static #"setLibraryView:") = Void, LibraryView;
overload selector(static #"libraryView") = Pointer[LibraryView];
overload selector(static #"setSearchString:") = Void, NSString;
overload selector(static #"searchString") = NSString;

maybeObject(x) = Id(x);
overload maybeObject(x: Nothing) = nil();
[T] overload maybeObject(x: Maybe[T]) = maybeObject(*x);

alias TrackIdsPboardType
    = NSString(#"com.duriansoftware.Vinyl.pasteboard.track_ids");
alias TrackPositionsPboardType
    = NSString(#"com.duriansoftware.Vinyl.pasteboard.track_positions");
alias PlaylistIdsPboardType
    = NSString(#"com.duriansoftware.Vinyl.pasteboard.playlist_ids");

alias PlaylistDidChangeNotification = NSString(#"VinylPlaylistDidChangeNotification");
alias PlaylistIDKey = NSString(#"VinylPlaylistID");

record PlaylistDataSource = newClass(NSObject,
    InstanceVars(
        library: Pointer[Library],
        tracks: Vector[PlaylistTrack],
        libraryView: LibraryView,
        searchString: Retained[NSString],
        playingTrackId: Maybe[NSInteger],
        playingMode: PlaylistMode,
    ),
    ClassMethods(),
    InstanceMethods(
        (#"initWithLibrary:sortDescriptors:", (self, library, sortDescriptors) =>
            initObjectWith(self, #"init", self => {
                self^.library = library;
                self^.tracks <-- Vector[PlaylistTrack]();
                self^.searchString <-- Retained(nil(NSString));
                self^.libraryView <-- LibraryView(SortedView(sortDescriptors));
                self^.playingTrackId <-- nothing(NSInteger);
                self^.playingMode <-- Paused;
                refreshPlaylistDataSource(self);
                return self;
            })
        ),
        DeallocInstanceMethod(),
        (#"numberOfRowsInTableView:", (self, tableView) => NSInteger(size(self^.tracks))),
        (#"tableView:objectValueForTableColumn:row:", (self, tableView, tableColumn, rowIndex) =>
            if (tableColumn.identifier() == "playing_p")
                maybe(self^.playingTrackId,
                    trackId =>
                        if (trackId == self^.tracks[rowIndex].track_id)
                            (if (self^.playingMode == Paused) Id(#"||") else Id(#">"))
                        else
                            nil(),
                    () => nil(),
                )
            else
                formattedFieldByName(self^.tracks[rowIndex], maybeObject, tableColumn.identifier())
        ),
        (#"tableView:deleteRowsWithIndexes:", (self, tableView, rowIndexes) => {
            match(self^.libraryView,
                PlaylistView, playlist => {
                    var rows = indexSetIndices(rowIndexes);

                    deleteLibraryPlaylistPositions(self^.library^, playlist.id, rows);
                    refreshPlaylistDataSource(self);
                    tableView.reloadData();
                    tableView.selectRowIndexes_byExtendingSelection(
                        NSIndexSet.indexSet(),
                        false
                    );
                    NSNotificationCenter.defaultCenter().postNotificationName_object_userInfo(
                        PlaylistDidChangeNotification,
                        self,
                        makeNSDictionary(PlaylistIDKey, playlist.id),
                    );
                },
                MatchDefault, _ => {}
            );
        }),
        (#"tableView:writeRowsWithIndexes:toPasteboard:", (self, tableView, rowIndexes, pasteboard) => {
            var filenames = NSMutableArray.array();
            var trackIds = NSMutableArray.array();
            var trackPositions = NSMutableArray.array();

            var rows = indexSetIndices(rowIndexes);

            for (row in rows) {
                filenames.addObject(self^.tracks[row].filename);
                trackIds.addObject(self^.tracks[row].track_id);
                trackPositions.addObject(row);
            }

            var localMask = match(self^.libraryView,
                PlaylistView,       v => bitwiseOr(NSDragOperationCopy, NSDragOperationMove, NSDragOperationDelete),
                PlaylistFolderView, v => bitwiseOr(NSDragOperationCopy, NSDragOperationDelete),
                SortedView,         v => bitwiseOr(NSDragOperationCopy, NSDragOperationDelete),
            );

            tableView.setDraggingSourceOperationMask_forLocal(
                NSUInteger(localMask),
                true
            );
            tableView.setDraggingSourceOperationMask_forLocal(
                NSUInteger(bitwiseOr(NSDragOperationCopy, NSDragOperationDelete)),
                false
            );

            pasteboard.declareTypes_owner(
                makeNSArray(NSFilenamesPboardType, TrackIdsPboardType, TrackPositionsPboardType),
                self
            );
            pasteboard.setPropertyList_forType(filenames, NSFilenamesPboardType);
            pasteboard.setPropertyList_forType(trackIds, TrackIdsPboardType);
            pasteboard.setPropertyList_forType(trackPositions, TrackPositionsPboardType);

            return true;
        }),

        (#"tableView:validateDrop:proposedRow:proposedDropOperation:", (self, tableView, info, row, operation) => {
            var allowDrop = match(self^.libraryView,
                PlaylistView, v => true,
                PlaylistFolderView, v => false,
                SortedView, v => false,
            );
            if (not allowDrop) return NSDragOperation(NSDragOperationNone);

            var pasteboard = info.draggingPasteboard();
            var pasteboardType = pasteboard.availableTypeFromArray(makeNSArray(TrackPositionsPboardType));
            if (nil?(pasteboardType))
                return NSDragOperation(NSDragOperationNone);

            if (row == -1)
                tableView.setDropRow_dropOperation(
                    tableView.numberOfRows(),
                    NSTableViewDropOperation(NSTableViewDropAbove)
                );
            else
                tableView.setDropRow_dropOperation(
                    row,
                    NSTableViewDropOperation(NSTableViewDropAbove)
                );
            return NSDragOperation(NSDragOperationMove);
        }),
        (#"tableView:acceptDrop:row:dropOperation:", (self, tableView, info, row, operation) => {
            var ok?, playlistId = ...match(self^.libraryView,
                PlaylistView,       v => ...(true, NSInteger(v.id)),
                PlaylistFolderView, v => ...(false, NSInteger(-1)),
                SortedView,         v => ...(false, NSInteger(-1)),
            );
            if (not ok?)
                return false;

            var pasteboard = info.draggingPasteboard();
            var pasteboardType = pasteboard.availableTypeFromArray(makeNSArray(TrackPositionsPboardType));
            if (nil?(pasteboardType))
                return false;

            var trackPositions = mapped(NSInteger, pasteboard.propertyListForType(pasteboardType));
            var newPosition = moveLibraryPlaylistTracks(self^.library^, playlistId, trackPositions, row);
            refreshPlaylistDataSource(self);
            tableView.reloadData();

            tableView.selectRowIndexes_byExtendingSelection(
                NSIndexSet.indexSetWithIndexesInRange(
                    NSMakeRange(NSUInteger(newPosition), NSUInteger(size(trackPositions)))
                ),
                false
            );

            NSNotificationCenter.defaultCenter().postNotificationName_object_userInfo(
                PlaylistDidChangeNotification,
                self,
                makeNSDictionary(PlaylistIDKey, playlistId),
            );

            return true;
        }),

        (#"tableView:sortDescriptorsDidChange:", (self, tableView, oldDescriptors) => {
            match(self^.libraryView,
                SortedView,   v => {
                    var sortDescriptors = tableView.sortDescriptors();
                    self^.libraryView = LibraryView(SortedView(sortDescriptors));
                    refreshPlaylistDataSource(self);
                    tableView.reloadData();
                },
                MatchDefault, v => {
                    
                },
            );
        }),

        (#"libraryView", self => &self^.libraryView),
        (#"setLibraryView:", (self, view) => {
            self^.libraryView = view;
            refreshPlaylistDataSource(self);
        }),
        (#"searchString", self => self^.searchString),
        (#"setSearchString:", (self, s) => {
            self^.searchString
                = if (s.length() == 0) Retained(nil(NSString)) else Retained(s.copy());
            refreshPlaylistDataSource(self);
        }),
        (#"tracks", self => &self^.tracks, Pointer[Vector[PlaylistTrack]]),
    ),
);

private alias basePlaylistSelectClause = "
    select
        tracks.track_id as track_id,
        tracks.filename as filename,
        tracks.display_name as name,
        tracks.sort_name as sort_name,
        albums.display_name as album_name,
        albums.sort_name as album_sort_name,
        album_artists.display_name as album_artist_name,
        album_artists.sort_name as album_artist_sort_name,
        albums.compilation_p as album_compilation_p,
        coalesce(track_artists.display_name, album_artists.display_name) as track_artist_name,
        coalesce(track_artists.sort_name,    album_artists.sort_name)    as track_artist_sort_name,
        genres.name as genre_name,
        composers.display_name as composer_name,
        composers.sort_name as composer_sort_name,
        groupings.name as grouping_name,
        tracks.side_number as side_number,
        albums.sides_count as sides_count,
        tracks.track_number as track_number,
        album_sides.tracks_count as tracks_count,
        tracks.duration_time as duration_time,
        tracks.year as year,
        tracks.comments as comments,
        coalesce(track_options.enabled_p, 1) as enabled_p,
        track_options.play_count as play_count,
        track_options.added_date as added_date,
        track_options.modified_date as modified_date,
        track_options.played_date as played_date
    ";

private alias basePlaylistFromClause = "
    from
        tracks
        left join albums on tracks.album_id = albums.album_id
        left join album_sides
            on tracks.album_id = album_sides.album_id
            and tracks.side_number = album_sides.side_number
        left join artists as album_artists on albums.album_artist_id = album_artists.artist_id
        left join artists as track_artists on tracks.track_artist_id = track_artists.artist_id
        left join genres on tracks.genre_id = genres.genre_id
        left join composers on tracks.composer_id = composers.composer_id
        left join groupings on tracks.grouping_id = groupings.grouping_id
        left join track_options on tracks.track_id = track_options.track_id
    ";

private alias searchPlaylistFromClause = "
    from
        tracks
        inner join tracks_fts
            on tracks_fts.docid = tracks.track_id
        left join albums on tracks.album_id = albums.album_id
        left join album_sides
            on tracks.album_id = album_sides.album_id
            and tracks.side_number = album_sides.side_number
        left join artists as album_artists on albums.album_artist_id = album_artists.artist_id
        left join artists as track_artists on tracks.track_artist_id = track_artists.artist_id
        left join genres on tracks.genre_id = genres.genre_id
        left join composers on tracks.composer_id = composers.composer_id
        left join groupings on tracks.grouping_id = groupings.grouping_id
        left join track_options on tracks.track_id = track_options.track_id
    ";

private  viewFromClauseAddition(view: SortedView) = "";
overload viewFromClauseAddition(view: PlaylistView) = "
        inner join playlist_tracks
            on tracks.track_id = playlist_tracks.track_id
    ";
overload viewFromClauseAddition(view: PlaylistFolderView) = "
        inner join playlist_tracks
            on tracks.track_id = playlist_tracks.track_id
        inner join playlists
            on playlist_tracks.playlist_id = playlists.playlist_id
    ";

private alias sortWhereClause = "
        tracks_fts.tracks_fts match :search
    ";

private  viewWhereClause(view: SortedView) = "1";
overload viewWhereClause(view: PlaylistView) = "
        playlist_tracks.playlist_id = :playlist_id
    ";
overload viewWhereClause(view: PlaylistFolderView) = "
        playlists.playlist_folder_id = :playlist_folder_id
    ";

private  viewOrderByClause(view: SortedView) = view.sort;
overload viewOrderByClause(view: PlaylistView) = String("playlist_tracks.position");
overload viewOrderByClause(view: PlaylistFolderView)
    = String("playlists.position, playlist_tracks.position");

private  bindViewParameters(stmt: SqliteStatement, view: SortedView) { }
overload bindViewParameters(stmt: SqliteStatement, view: PlaylistView) {
    bindStatement(stmt, ":playlist_id", view.id);
}
overload bindViewParameters(stmt: SqliteStatement, view: PlaylistFolderView) {
    bindStatement(stmt, ":playlist_folder_id", view.id);
}

libraryViewStatement(db: SqliteDB, search: String, view: LibraryView) {
    var searching? = not empty?(search);
    var stmtString = String(basePlaylistSelectClause);
    if (searching?)
        stmtString += searchPlaylistFromClause;
    else
        stmtString += basePlaylistFromClause;
    stmtString += viewFromClauseAddition(*view);
    stmtString += " where ";
    if (searching?)
        stmtString += sortWhereClause + " and ";
    stmtString += viewWhereClause(*view);
    stmtString += " order by ";
    stmtString += viewOrderByClause(*view);

    var stmt = SqliteStatement(db, stmtString);
    if (searching?)
        bindStatement(stmt, ":search", search);
    bindViewParameters(stmt, *view);
    return move(stmt);
}

refreshPlaylistDataSource(self: PlaylistDataSource) {
    clear(self^.tracks);

    var search = if (nil?(self^.searchString))
            String()
        else
            String(self^.searchString) + "*";

    var stmt = libraryViewStatement(self^.library^.db, search, self^.libraryView);

    for (row in stmt)
        push(self^.tracks, rowRecord(row, PlaylistTrack));
}
