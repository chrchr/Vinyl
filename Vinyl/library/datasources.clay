import cocoa.*;
import cocoa.appkit.*;
import sqlite.*;
import maybe.*;
import Vinyl.library.*;
import Vinyl.controls.deletingtableview.*;


//
// data source for library outline view
//

overload selector(static #"initWithLibrary:") = Id, Pointer[Library];
overload selector(static #"insertPlaylistWithName:parentItem:")
    = Id, NSString, Id;

libraryDataSourceItemCount(self: LibraryDataSource)
    = NSInteger(
        1 // Library
        + self^.folders.count() // folders
        + self^.playlists.count() // toplevel playlists
    );

record LibraryDataSource = newClass(NSObject,
    InstanceVars(
        (#library, Pointer[Library]),
        (#folders, Retained[NSMutableArray]),
        (#playlists, Retained[NSMutableArray]),
    ),
    ClassMethods(
    ),
    InstanceMethods(
        (#"initWithLibrary:", (self, library) => initObjectWith(self, #"init", self => {
            self^.library = library;
            self^.folders = NSMutableArray.array();
            self^.playlists = NSMutableArray.array();
            refreshLibraryDataSource(self);
            return self;
        })),
        DeallocInstanceMethod(),
        (#"outlineView:numberOfChildrenOfItem:", (self, outlineView, item) =>
            if (nil?(item))
                libraryDataSourceItemCount(self)
            else if (itemIsFolder?(item))
                NSInteger(item["playlists"].count()) // playlist folder
            else
                NSInteger(0) // library or playlist, no children
        ),
        (#"outlineView:isItemExpandable:", (self, outlineView, item) => itemIsFolder?(item)),
        (#"outlineView:child:ofItem:", (self, outlineView, index, item) => {
            if (nil?(item)) {
                if (index == 0)
                    return Id(NSString(#"Library"));
                else {
                    var numFolders = self^.folders.count();
                    if (index - 1 < numFolders)
                        return self^.folders[index - 1];
                    else
                        return self^.playlists[index - numFolders - 1];
                }
            } else
                return item["playlists"][index];
        }),
        (#"outlineView:objectValueForTableColumn:byItem:", (self, outlineView, column, item) => {
            if (item.isKindOfClass(NSString))
                return item;
            else
                return item["name"];
        }),
        (#"outlineView:persistentObjectForItem:", (self, outlineView, item) => {
            if (itemIsFolder?(item))
                return item["id"];
            else
                return nil(Id);
        }),
        (#"outlineView:itemForPersistentObject:", (self, outlineView, object) => {
            println(object);
            if (object.isKindOfClass(NSNumber)) {
                for (folder in self^.folders)
                    if (folder["id"] == object)
                        return folder;
            }
            return nil(Id);
        }),
        (#"outlineView:setObjectValue:forTableColumn:byItem:", (self, outlineView, value, column, item) => {
            if (item.isKindOfClass(NSString))
                return;
            else if (value.description().length() == 0)
                return;
            else {
                item.setObject_forKey(value.description(), "name");
                if (itemIsFolder?(item))
                    updateLibraryFolderName(self^.library^, Int(item["id"]), String(value));
                else
                    updateLibraryPlaylistName(self^.library^, Int(item["id"]), String(value));
            }
        }),
        (#"outlineView:deleteItem:", (self, outlineView, item) => {
            if (item.isKindOfClass(NSString))
                return;
            var parentItem = outlineView.parentForItem(item);

            if (itemIsFolder?(item)) {
                deleteLibraryFolder(self^.library^, Int(item["id"]));
                self^.folders.removeObject(item);
            } else {
                deleteLibraryPlaylist(self^.library^, Int(item["id"]));
                self^.playlists.removeObject(item);
                for (folder in self^.folders)
                    folder["playlists"].removeObject(item);
            }

            outlineView.reloadData();
            if (nil?(parentItem))
                outlineView.selectRowIndexes_byExtendingSelection(
                    NSIndexSet.indexSetWithIndex(NSUInteger(0)),
                    false
                );
            else {
                var parentRow = outlineView.rowForItem(parentItem);
                outlineView.selectRowIndexes_byExtendingSelection(
                    NSIndexSet.indexSetWithIndex(NSUInteger(parentRow)),
                    false
                );
            }
        }),

        /* XXX drag out
        (#"outlineView:writeItems:toPasteboard:", (self, tableView, rowIndexes, pasteboard) => {
        })
        */

        (#"outlineView:validateDrop:proposedItem:proposedChildIndex:", (self, outlineView, info, item, index) => {
            if (item.isKindOfClass(NSString))
                return NSDragOperation(NSDragOperationNone);

            var pasteboard = info.draggingPasteboard();
            var pasteboardType = pasteboard.availableTypeFromArray(makeNSArray(TrackIdsPboardType));
            if (nil?(pasteboardType))
                return NSDragOperation(NSDragOperationNone);

            if (nil?(item))
                outlineView.setDropItem_dropChildIndex(
                    nil(),
                    NSInteger(-1)
                );
            else if (itemIsFolder?(item))
                outlineView.setDropItem_dropChildIndex(
                    item,
                    NSInteger(item["playlists"].count())
                );
            return NSDragOperation(NSDragOperationCopy);
        }),

        (#"outlineView:acceptDrop:item:childIndex:", (self, outlineView, info, item, index) => {
            if (item.isKindOfClass(NSString))
                return false;

            var pasteboard = info.draggingPasteboard();
            var pasteboardType = pasteboard.availableTypeFromArray(makeNSArray(TrackIdsPboardType));
            if (nil?(pasteboardType))
                return false;

            var trackIds = NSArray(pasteboard.propertyListForType(pasteboardType));

            var playlistItem = if (itemIsPlaylist?(item))
                item
            else
                self.insertPlaylistWithName_parentItem(
                    #"New Playlist", // XXX derive playlist name from track attributes
                    item
                );

            insertLibraryPlaylistTracks(self^.library^, NSInteger(playlistItem["id"]), mapped(NSInteger, trackIds));

            outlineView.reloadData();
            if (itemIsFolder?(item))
                outlineView.expandItem(item);

            var playlistRow = outlineView.rowForItem(playlistItem);
            outlineView.selectRowIndexes_byExtendingSelection(
                NSIndexSet.indexSetWithIndex(NSUInteger(playlistRow)),
                false
            );
            outlineView.editColumn_row_withEvent_select(
                NSInteger(0),
                NSInteger(playlistRow),
                nil(NSEvent),
                true
            );

            return true;
        }),

        (#"insertPlaylistWithName:parentItem:", (self, name, parentItem) => {
            var parentId = if (itemIsFolder?(parentItem))
                Maybe(NSInteger(parentItem["id"]))
            else
                nothing(NSInteger);

            var id = insertLibraryPlaylist(self^.library^, String(name), parentId);

            var newItem = makeNSMutableDictionary("id", id, "name", name);

            if (itemIsFolder?(parentItem))
                parentItem["playlists"].addObject(newItem);
            else
                self^.playlists.addObject(newItem);

            return newItem;
        }),

    ),
);

refreshLibraryDataSource(self: LibraryDataSource) {
    self^.folders.removeAllObjects();
    self^.playlists.removeAllObjects();

    var folderPositions = HashMap[NSUInteger, NSUInteger]();

    for (row in SqliteStatement(self^.library^.db,
        "select playlist_folder_id, name from playlist_folders order by position"
    )) {
        folderPositions[row[0, NSUInteger]] = size(self^.folders);
        self^.folders.addObject(makeNSMutableDictionary(
            "id", row[0, Int],
            "name", row[1],
            "playlists", NSMutableArray.array()
        ));
    }

    for (row in SqliteStatement(self^.library^.db,
        "select playlist_id, name, playlist_folder_id from playlists
            order by playlist_folder_id, position"
    )) {
        var folder = nil(NSMutableArray);

        if (nullColumn?(row, 2)) {
            folder = self^.playlists;
        } else {
            var folderPosition = folderPositions[row[2, NSUInteger]];
            folder = self^.folders[folderPosition]["playlists"];
        }

        folder.addObject(makeNSMutableDictionary(
            "id", row[0, Int],
            "name", row[1]
        ));
    }
}

itemIsPlaylist?(item) = item.isKindOfClass(NSDictionary) and nil?(item["playlists"]);
itemIsFolder?(item) = item.isKindOfClass(NSDictionary) and not nil?(item["playlists"]);



//
// data source for library
//
enum SortDirection { SortAscending, SortDescending }

record SortDescriptor (column: String, direction: SortDirection);

sortSQL(sortColumn: String) {
    switch (sortColumn) {
    case "filename":
    case "name":
    case "sort_name":
        return "tracks.sort_name";
    case "album_name":
    case "album_sort_name":
        return "albums.sort_name";
    case "album_artist_name":
    case "album_artist_sort_name":
        return "album_artists.sort_name";
    case "album_compilation_p":
        return "not albums.compilation_p";
    case "track_artist_name":
    case "track_artist_sort_name":
        return "track_artists.sort_name";
    case "genre_name":
        return "genres.name";
    case "composer_name":
    case "composer_sort_name":
        return "composers.sort_name";
    case "grouping_name":
        return "groupings.name";
    case "side_number":
    case "sides_count":
        return "tracks.side_number";
    case "track_number":
    case "tracks_count":
        return "tracks.track_number";
    case "duration_time":
        return "tracks.duration_time";
    case "year":
        return "cast(tracks.year as integer)";
    case "comments":
        return "tracks.comments";
    case "enabled_p":
        return "not enabled_p";
    case "play_count":
        return "track_options.play_count";
    case "added_date":
        return "track_options.added_date";
    case "modified_date":
        return "track_options.modified_date";
    case "played_date":
        return "track_options.played_date";
    case "track_id":
        return "tracks.track_id";
    default:
        return "tracks.track_id";
    }
}

overload sortSQL(sortDescriptor: SortDescriptor) {
    var baseSort = sortSQL(sortDescriptor.column);
    if (sortDescriptor.direction == SortDescending)
        return baseSort + " desc";
    else
        return baseSort;
}

[S | Sequence?(S) and SequenceElementType(S) == SortDescriptor]
overload sortSQL(descriptors: S) = join(", ", mapped(sortSQL, descriptors));

record PlaylistFolderView (id: Int);
record PlaylistView (id: Int);
record SortedView (sort: String);
variant LibraryView = PlaylistFolderView | PlaylistView | SortedView;

[S | String?(S) and S != String]
overload SortedView(sort: S) = SortedView(String(sort));
overload SortedView() = SortedView(sortSQL(String("name")));

overload LibraryView() = LibraryView(SortedView());

// XXX store sort names too
record PlaylistTrack (
    track_id: Int,
    filename: String,
    name: String,
    sort_name: Maybe[String],
    album_name: Maybe[String],
    album_sort_name: Maybe[String],
    album_artist_name: Maybe[String],
    album_artist_sort_name: Maybe[String],
    album_compilation_p: Bool,
    track_artist_name: Maybe[String],
    track_artist_sort_name: Maybe[String],
    genre_name: Maybe[String],
    composer_name: Maybe[String],
    composer_sort_name: Maybe[String],
    grouping_name: Maybe[String],
    side_number: Maybe[Int],
    sides_count: Maybe[Int],
    track_number: Maybe[Int],
    tracks_count: Maybe[Int],
    duration_time: Double,
    year: Maybe[String],
    comments: Maybe[String],
    enabled_p: Bool,
    play_count: Maybe[Int],
    added_date: Maybe[Int],
    modified_date: Maybe[Int],
    played_date: Maybe[Int]
);

overload PlaylistTrack() = PlaylistTrack(
    0,
    String(),
    String(),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    false,
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[String](),
    Maybe[Int](),
    Maybe[Int](),
    Maybe[Int](),
    Maybe[Int](),
    0.0,
    Maybe[String](),
    Maybe[String](),
    true,
    Maybe[Int](),
    Maybe[Int](),
    Maybe[Int](),
    Maybe[Int](),
);

record NoFieldForString (type: StringConstant, string: String);
instance Exception = NoFieldForString;

[R | Record?(R)]
fieldByName(forward r: R, fn, str) {
    static for (fieldName in ...mapValues(x => x.0, ...RecordFields(R))) {
        if (str == StaticName(fieldName))
            return forward fn(fieldRef(r, fieldName));
    }
    throw NoFieldForString(StaticName(R), String(str));
}

overload selector(static #"setLibraryView:") = Void, LibraryView;
overload selector(static #"libraryView") = Pointer[LibraryView];
overload selector(static #"setSearchString:") = Void, NSString;
overload selector(static #"searchString") = NSString;

maybeObject(x) = Id(x);
overload maybeObject(x: Nothing) = nil();
[T] overload maybeObject(x: Maybe[T]) = maybeObject(*x);

alias TrackIdsPboardType
    = NSString(#"com.duriansoftware.Vinyl.pasteboard.track_ids");

record PlaylistDataSource = newClass(NSObject,
    InstanceVars(
        library: Pointer[Library],
        tracks: Vector[PlaylistTrack],
        libraryView: LibraryView,
        searchString: Retained[NSString],
    ),
    ClassMethods(),
    InstanceMethods(
        (#"initWithLibrary:", (self, library) => initObjectWith(self, #"init", self => {
            self^.library = library;
            self^.tracks <-- Vector[PlaylistTrack]();
            self^.libraryView <-- LibraryView();
            self^.searchString <-- Retained(nil(NSString));
            refreshPlaylistDataSource(self);
            return self;
        })),
        DeallocInstanceMethod(),
        (#"numberOfRowsInTableView:", (self, tableView) => NSInteger(size(self^.tracks))),
        (#"tableView:objectValueForTableColumn:row:", (self, tableView, tableColumn, rowIndex) =>
            fieldByName(self^.tracks[rowIndex], maybeObject, tableColumn.identifier())
        ),
        (#"tableView:deleteRowsWithIndexes:", (self, tableView, rowIndexes) => {
            match(self^.libraryView,
                PlaylistView, playlist => {
                    var rows = Vector[NSUInteger]();
                    var rowCount = rowIndexes.count();
                    resize(rows, rowCount);
                    rowIndexes.getIndexes_maxCount_inIndexRange(
                        begin(rows),
                        rowCount,
                        NSRangePointer(0),
                    );

                    deleteLibraryPlaylistPositions(self^.library^, playlist.id, rows);
                    refreshPlaylistDataSource(self);
                    tableView.reloadData();
                    tableView.selectRowIndexes_byExtendingSelection(
                        NSIndexSet.indexSet(),
                        false
                    );
                },
                MatchDefault, _ => {}
            );
        }),
        (#"tableView:writeRowsWithIndexes:toPasteboard:", (self, tableView, rowIndexes, pasteboard) => {
            var filenames = NSMutableArray.array();
            var trackIds = NSMutableArray.array();

            var rows = Vector[NSUInteger]();
            var rowCount = rowIndexes.count();
            resize(rows, rowCount);
            rowIndexes.getIndexes_maxCount_inIndexRange(
                begin(rows),
                rowCount,
                NSRangePointer(0),
            );

            for (row in rows) {
                filenames.addObject(self^.tracks[row].filename);
                trackIds.addObject(self^.tracks[row].track_id);
            }

            var localMask = match(self^.libraryView,
                PlaylistView, v => bitwiseOr(NSDragOperationCopy, NSDragOperationMove, NSDragOperationDelete),
                PlaylistFolderView, v => bitwiseOr(NSDragOperationCopy, NSDragOperationMove, NSDragOperationDelete),
                SortedView, v => bitwiseOr(NSDragOperationCopy, NSDragOperationDelete),
            );

            tableView.setDraggingSourceOperationMask_forLocal(
                NSUInteger(localMask),
                true
            );
            tableView.setDraggingSourceOperationMask_forLocal(
                NSUInteger(bitwiseOr(NSDragOperationCopy, NSDragOperationDelete)),
                false
            );

            pasteboard.declareTypes_owner(
                makeNSArray(NSFilenamesPboardType, TrackIdsPboardType),
                self
            );
            pasteboard.setPropertyList_forType(filenames, NSFilenamesPboardType);
            pasteboard.setPropertyList_forType(trackIds, TrackIdsPboardType);

            return true;
        }),

        (#"tableView:validateDrop:proposedRow:proposedDropOperation:", (self, tableView, info, row, operation) => {
            var allowDrop = match(self^.libraryView,
                PlaylistView, v => true,
                PlaylistFolderView, v => false,
                SortedView, v => false,
            );
            if (not allowDrop) return NSDragOperation(NSDragOperationNone);

            var pasteboard = info.draggingPasteboard();
            var pasteboardType = pasteboard.availableTypeFromArray(makeNSArray(TrackIdsPboardType));
            if (nil?(pasteboardType))
                return NSDragOperation(NSDragOperationNone);

            if (row == -1)
                tableView.setDropRow_dropOperation(
                    tableView.numberOfRows(),
                    NSTableViewDropOperation(NSTableViewDropAbove)
                );
            else
                tableView.setDropRow_dropOperation(
                    row,
                    NSTableViewDropOperation(NSTableViewDropAbove)
                );
            return NSDragOperation(NSDragOperationMove);
        }),
        (#"tableView:acceptDrop:row:dropOperation:", (self, tableView, info, row, operation) => {
            var ok?, playlistId = ...match(self^.libraryView,
                PlaylistView, v => ...(true, NSInteger(v.id)),
                PlaylistFolderView, v => ...(false, NSInteger(-1)),
                SortedView, v => ...(false, NSInteger(-1)),
            );
            if (not ok?)
                return false;

            var pasteboard = info.draggingPasteboard();
            var pasteboardType = pasteboard.availableTypeFromArray(makeNSArray(TrackIdsPboardType));
            if (nil?(pasteboardType))
                return false;

            var trackIds = mapped(NSInteger, pasteboard.propertyListForType(pasteboardType));
            var newPosition = moveLibraryPlaylistTracks(self^.library^, playlistId, trackIds, row);
            refreshPlaylistDataSource(self);
            tableView.reloadData();

            tableView.selectRowIndexes_byExtendingSelection(
                NSIndexSet.indexSetWithIndexesInRange(
                    NSMakeRange(NSUInteger(newPosition), NSUInteger(size(trackIds)))
                ),
                false
            );

            return true;
        }),

        (#"libraryView", self => &self^.libraryView),
        (#"setLibraryView:", (self, view) => {
            self^.libraryView = view;
            refreshPlaylistDataSource(self);
        }),
        (#"searchString", self => self^.searchString),
        (#"setSearchString:", (self, s) => {
            self^.searchString
                = if (s.length() == 0) Retained(nil(NSString)) else Retained(s.copy());
            refreshPlaylistDataSource(self);
        }),
        (#"tracks", self => &self^.tracks, Pointer[Vector[PlaylistTrack]]),
    ),
);

private alias basePlaylistSelectClause = "
    select
        tracks.track_id as track_id,
        tracks.filename as filename,
        tracks.display_name as name,
        tracks.sort_name as sort_name,
        albums.display_name as album_name,
        albums.sort_name as album_sort_name,
        album_artists.display_name as album_artist_name,
        album_artists.sort_name as album_artist_sort_name,
        albums.compilation_p as album_compilation_p,
        track_artists.display_name as track_artist_name,
        track_artists.sort_name as track_artist_sort_name,
        genres.name as genre_name,
        composers.display_name as composer_name,
        composers.sort_name as composer_sort_name,
        groupings.name as grouping_name,
        tracks.side_number as side_number,
        albums.sides_count as sides_count,
        tracks.track_number as track_number,
        album_sides.tracks_count as tracks_count,
        tracks.duration_time as duration_time,
        tracks.year as year,
        tracks.comments as comments,
        coalesce(track_options.enabled_p, 1) as enabled_p,
        track_options.play_count as play_count,
        track_options.added_date as added_date,
        track_options.modified_date as modified_date,
        track_options.played_date as played_date
    ";

private alias basePlaylistFromClause = "
    from
        tracks
        left join albums on tracks.album_id = albums.album_id
        left join album_sides
            on tracks.album_id = album_sides.album_id
            and tracks.side_number = album_sides.side_number
        left join artists as album_artists on albums.album_artist_id = album_artists.artist_id
        left join artists as track_artists on tracks.track_artist_id = track_artists.artist_id
        left join genres on tracks.genre_id = genres.genre_id
        left join composers on tracks.composer_id = composers.composer_id
        left join groupings on tracks.grouping_id = groupings.grouping_id
        left join track_options on tracks.track_id = track_options.track_id
    ";

private alias searchPlaylistFromClause = "
    from
        tracks
        inner join tracks_fts
            on tracks_fts.docid = tracks.track_id
        left join albums on tracks.album_id = albums.album_id
        left join album_sides
            on tracks.album_id = album_sides.album_id
            and tracks.side_number = album_sides.side_number
        left join artists as album_artists on albums.album_artist_id = album_artists.artist_id
        left join artists as track_artists on tracks.track_artist_id = track_artists.artist_id
        left join genres on tracks.genre_id = genres.genre_id
        left join composers on tracks.composer_id = composers.composer_id
        left join groupings on tracks.grouping_id = groupings.grouping_id
        left join track_options on tracks.track_id = track_options.track_id
    ";

private  viewFromClauseAddition(view: SortedView) = "";
overload viewFromClauseAddition(view: PlaylistView) = "
        inner join playlist_tracks
            on tracks.track_id = playlist_tracks.track_id
    ";
overload viewFromClauseAddition(view: PlaylistFolderView) = "
        inner join playlist_tracks
            on tracks.track_id = playlist_tracks.track_id
        inner join playlists
            on playlist_tracks.playlist_id = playlists.playlist_id
    ";

private alias sortWhereClause = "
        tracks_fts.tracks_fts match :search
    ";

private  viewWhereClause(view: SortedView) = "1";
overload viewWhereClause(view: PlaylistView) = "
        playlist_tracks.playlist_id = :playlist_id
    ";
overload viewWhereClause(view: PlaylistFolderView) = "
        playlists.playlist_folder_id = :playlist_folder_id
    ";

private  viewOrderByClause(view: SortedView) = view.sort;
overload viewOrderByClause(view: PlaylistView) = String("playlist_tracks.position");
overload viewOrderByClause(view: PlaylistFolderView)
    = String("playlists.position, playlist_tracks.position");

private  bindViewParameters(stmt: SqliteStatement, view: SortedView) { }
overload bindViewParameters(stmt: SqliteStatement, view: PlaylistView) {
    bindStatement(stmt, ":playlist_id", view.id);
}
overload bindViewParameters(stmt: SqliteStatement, view: PlaylistFolderView) {
    bindStatement(stmt, ":playlist_folder_id", view.id);
}

libraryViewStatement(db: SqliteDB, search: String, view: LibraryView) {
    var searching? = not empty?(search);
    var stmtString = String(basePlaylistSelectClause);
    if (searching?)
        stmtString += searchPlaylistFromClause;
    else
        stmtString += basePlaylistFromClause;
    stmtString += viewFromClauseAddition(*view);
    stmtString += " where ";
    if (searching?)
        stmtString += sortWhereClause + " and ";
    stmtString += viewWhereClause(*view);
    stmtString += " order by ";
    stmtString += viewOrderByClause(*view);

    var stmt = SqliteStatement(db, stmtString);
    if (searching?)
        bindStatement(stmt, ":search", search);
    bindViewParameters(stmt, *view);
    return move(stmt);
}

refreshPlaylistDataSource(self: PlaylistDataSource) {
    clear(self^.tracks);

    var search = if (nil?(self^.searchString))
            String()
        else
            String(self^.searchString) + "*";

    var stmt = libraryViewStatement(self^.library^.db, search, self^.libraryView);

    for (row in stmt)
        push(self^.tracks, rowRecord(row, PlaylistTrack));
}
