import cocoa.*;
import sqlite.*;
import maybe.*;

alias LIBRARY_DB_FILE = "Vinyl Library.sqlite";

supportDir() {
    var applicationSupportDirs = NSSearchPathForDirectoriesInDomains(
        NSUInteger(NSApplicationSupportDirectory),
        NSUInteger(NSUserDomainMask),
        true
    );
    var applicationSupportDir = NSString(applicationSupportDirs[0]);

    return applicationSupportDir.stringByAppendingPathComponent("Durian Software/Vinyl");
}

libraryFile(dir) = dir.stringByAppendingPathComponent(LIBRARY_DB_FILE);

record Library (db: SqliteDB);

createLibraryDatabase(db: SqliteDB) {
    withTransaction(db, () ref=> {
        runStatement(db, "create table artists (
            artist_id integer primary key,
            display_name text not null,
            sort_name text not null
        )");
        runStatement(db, "create table albums (
            album_id integer primary key,
            display_name text not null,
            sort_name text not null,
            album_artist_id integer references artists (artist_id),
            sides_count integer,
            compilation_p integer not null default 0
        )");
        runStatement(db, "create table album_sides (
            album_id integer not null references albums (album_id),
            side_number integer not null,
            tracks_count integer,
            primary key (album_id, side_number)
        )");
        runStatement(db, "create table genres (
            genre_id integer primary key,
            name text not null
        )");
        runStatement(db, "create table composers (
            composer_id integer primary key,
            display_name text not null,
            sort_name text not null
        )");
        runStatement(db, "create table groupings (
            grouping_id integer primary key,
            name text not null
        )");
        runStatement(db, "create table tracks (
            track_id integer primary key,
            filename text not null unique,
            display_name text not null,
            sort_name text not null,
            album_id integer references albums (album_id),
            track_artist_id integer references artist (artist_id),
            genre_id integer references genres (genre_id),
            composer_id integer references composers (composer_id),
            grouping_id integer references groupings (grouping_id),
            side_number integer,
            track_number integer,
            duration_time real not null,
            year text,
            comments text
        )");
        
        runStatement(db, "create table playlist_folders (
            playlist_folder_id integer primary key,
            name text not null,
            position integer unique not null
        )");
        runStatement(db, "create table playlists (
            playlist_id integer primary key,
            name text not null,
            playlist_folder_id integer references playlist_folders (playlist_folder_id),
            position integer not null,
            unique (playlist_folder_id, position)
        )");
        runStatement(db, "create table playlist_tracks (
            playlist_id integer references playlists (playlist_id) not null,
            track_id integer references tracks (track_id) not null,
            position integer not null,
            primary key (playlist_id, track_id, position),
            unique (playlist_id, position)
        )");
        
        runStatement(db, "create table album_options (
            album_id integer primary key references albums (album_id),
            rating integer
        )");
        runStatement(db, "create table track_options (
            track_id integer primary key references tracks (track_id),
            enabled_p integer not null default 0,
            rating integer,
            start_time real,
            end_time real,
            play_count integer not null default 0,
            added_date integer,
            modified_date integer,
            played_date integer
        )");
    });
}

createLibrary(file) {
    var db = SqliteDB(file);
    createLibraryDatabase(db);
    return Library(move(db));
}

overload Library() {
    var dir = supportDir();
    var file = libraryFile(dir);
    var fm = Retained(NSFileManager.alloc().init());
    if (fm.fileExistsAtPath(file)) {
        return Library(SqliteDB(String(file)));
    } else {
        fm.createDirectoryAtPath_withIntermediateDirectories_attributes_error(
            dir, true, nil(NSDictionary), null(NSError)
        );
        return createLibrary(String(file));
    }
}

// XXX include data source update here 
updateLibraryFolderName(library: Library, folderId, name) {
    runStatement(library.db, "update playlist_folders set name = ? where playlist_folder_id = ?",
        name, folderId
    );
}

updateLibraryPlaylistName(library: Library, playlistId, name) {
    runStatement(library.db, "update playlists set name = ? where playlist_id = ?",
        name, playlistId
    );
}



//
// data source for library outline view
//

overload selector(static #"initWithLibrary:") = Id, Pointer[Library];

record LibraryDataSource = newClass(NSObject,
    InstanceVars(
        (#library, Pointer[Library]),
        (#folders, Retained[NSMutableArray]),
        (#playlists, Retained[NSMutableArray]),
    ),
    ClassMethods(
    ),
    InstanceMethods(
        (#"initWithLibrary:", (self, library) => initObjectWith(self, #"init", self => {
            self^.library = library;
            self^.folders = NSMutableArray.array();
            self^.playlists = NSMutableArray.array();
            refreshLibraryDataSource(self);
            return self;
        })),
        DeallocInstanceMethod(),
        (#"outlineView:numberOfChildrenOfItem:", (self, outlineView, item) =>
            if (nil?(item))
                NSInteger(
                    1 // Library
                    + self^.folders.count() // folders
                    + self^.playlists.count() // toplevel playlists
                )
            else if (itemIsFolder?(item))
                NSInteger(item["playlists"].count()) // playlist folder
            else
                NSInteger(0) // library or playlist, no children
        ),
        (#"outlineView:isItemExpandable:", (self, outlineView, item) => itemIsFolder?(item)),
        (#"outlineView:child:ofItem:", (self, outlineView, index, item) => {
            if (nil?(item)) {
                if (index == 0)
                    return Id(NSString(#"Library"));
                else {
                    var numFolders = self^.folders.count();
                    if (index - 1 < numFolders)
                        return self^.folders[index - 1];
                    else
                        return self^.playlists[index - numFolders - 1];
                }
            } else
                return item["playlists"][index];
        }),
        (#"outlineView:objectValueForTableColumn:byItem:", (self, outlineView, column, item) => {
            if (item.isKindOfClass(NSString))
                return item;
            else
                return item["name"];
        }),
        (#"outlineView:persistentObjectForItem:", (self, outlineView, item) => {
            if (itemIsFolder?(item))
                return item["id"];
            else
                return nil(Id);
        }),
        (#"outlineView:itemForPersistentObject:", (self, outlineView, object) => {
            println(object);
            if (object.isKindOfClass(NSNumber)) {
                for (folder in self^.folders)
                    if (folder["id"] == object)
                        return folder;
            }
            return nil(Id);
        }),
        (#"outlineView:setObjectValue:forTableColumn:byItem:", (self, outlineView, value, column, item) => {
            if (item.isKindOfClass(NSString))
                return;
            else {
                item.setObject_forKey(value.description(), "name");
                if (itemIsFolder?(item))
                    updateLibraryFolderName(self^.library^, Int(item["id"]), String(value));
                else
                    updateLibraryPlaylistName(self^.library^, Int(item["id"]), String(value));
            }
        }),
    ),
);

refreshLibraryDataSource(self: LibraryDataSource) {
    self^.folders.removeAllObjects();
    self^.playlists.removeAllObjects();

    var folderPositions = HashMap[NSUInteger, NSUInteger]();

    for (row in SqliteStatement(self^.library^.db,
        "select playlist_folder_id, name from playlist_folders order by position"
    )) {
        folderPositions[row[0, NSUInteger]] = size(self^.folders);
        self^.folders.addObject(makeNSMutableDictionary(
            "id", row[0, Int],
            "name", row[1],
            "playlists", NSMutableArray.array()
        ));
    }

    for (row in SqliteStatement(self^.library^.db,
        "select playlist_id, name, playlist_folder_id from playlists
            order by playlist_folder_id, position"
    )) {
        var folder = nil(NSMutableArray);

        if (nullColumn?(row, 2)) {
            folder = self^.playlists;
        } else {
            var folderPosition = folderPositions[row[2, NSUInteger]];
            folder = self^.folders[folderPosition]["playlists"];
        }

        folder.addObject(makeNSMutableDictionary(
            "id", row[0, Int],
            "name", row[1]
        ));
    }
}

itemIsPlaylist?(item) = item.isKindOfClass(NSDictionary) and nil?(item["playlists"]);
itemIsFolder?(item) = item.isKindOfClass(NSDictionary) and not nil?(item["playlists"]);



//
// data source for library
//

record PlaylistFolderView (id: Int);
record PlaylistView (id: Int);
record SortedView (sort: String);
variant LibraryView = PlaylistFolderView | PlaylistView | SortedView;

[S | String?(S) and S != String]
overload SortedView(sort: S) = SortedView(String(sort));
overload SortedView() = SortedView("tracks.sort_name");

overload LibraryView() = LibraryView(SortedView());

record PlaylistTrack (
    track_id: Int,
    filename: String,
    name: String,
    album_name: String,
    album_artist_name: String,
    track_artist_name: String,
    genre_name: String,
    composer_name: String,
    grouping_name: String,
    side_number: Int,
    sides_count: Int,
    track_number: Int,
    tracks_count: Int,
    duration_time: Double,
    year: String,
    comments: String,
    enabled_p: Int,
    play_count: Int,
    added_date: Int,
    modified_date: Int,
    played_date: Int
);

record NoFieldForString (type: StringConstant, string: String);
instance Exception = NoFieldForString;

[R | Record?(R)]
fieldByName(forward r: R, fn, str) {
    static for (fieldName in ...mapValues(x => x.0, ...RecordFields(R))) {
        if (str == StaticName(fieldName))
            return forward fn(fieldRef(r, fieldName));
    }
    throw NoFieldForString(StaticName(R), String(str));
}

overload selector(static #"setLibraryView:") = Void, LibraryView;
overload selector(static #"libraryView") = Pointer[LibraryView];

record PlaylistDataSource = newClass(NSObject,
    InstanceVars(
        library: Pointer[Library],
        tracks: Vector[PlaylistTrack],
        libraryView: LibraryView,
    ),
    ClassMethods(),
    InstanceMethods(
        (#"initWithLibrary:", (self, library) => initObjectWith(self, #"init", self => {
            self^.library = library;
            self^.tracks <-- Vector[PlaylistTrack]();
            self^.libraryView <-- LibraryView();
            refreshPlaylistDataSource(self);
            return self;
        })),
        DeallocInstanceMethod(),
        (#"numberOfRowsInTableView:", (self, tableView) => NSInteger(size(self^.tracks))),
        (#"tableView:objectValueForTableColumn:row:", (self, tableView, tableColumn, rowIndex) =>
            fieldByName(self^.tracks[rowIndex], objectHandle, tableColumn.identifier())
        ),
        (#"libraryView", self => &self^.libraryView),
        (#"setLibraryView:", (self, view) => {
            self^.libraryView = view;
            refreshPlaylistDataSource(self);
        }),
        (#"tracks", self => &self^.tracks, Pointer[Vector[PlaylistTrack]]),
    ),
);

alias playlistQuery = "
        select
            tracks.track_id,
            tracks.filename,
            tracks.display_name as name,
            coalesce(albums.display_name, '') as album_name,
            coalesce(album_artists.display_name, '') as album_artist_name,
            coalesce(track_artists.display_name, '') as track_artist_name,
            coalesce(genres.name, '') as genre_name,
            coalesce(composers.display_name, '') as composer_name,
            coalesce(groupings.name, '') as grouping_name,
            coalesce(tracks.side_number, 0) as side_number,
            coalesce(albums.sides_count, 0) as sides_count,
            coalesce(tracks.track_number, 0) as track_number,
            coalesce(album_sides.tracks_count, 0) as tracks_count,
            tracks.duration_time as duration_time,
            coalesce(tracks.year, '') as year,
            coalesce(tracks.comments, '') as comments,
            coalesce(track_options.enabled_p, 1) as enabled_p,
            coalesce(track_options.play_count, 0) as play_count,
            coalesce(track_options.added_date, 0) as added_date,
            coalesce(track_options.modified_date, 0) as modified_date,
            coalesce(track_options.played_date, 0) as played_date
        from
            tracks
            left join albums on tracks.album_id = albums.album_id
            left join album_sides
                on tracks.album_id = album_sides.album_id
                and tracks.side_number = album_sides.side_number
            left join artists as album_artists on albums.album_artist_id = album_artists.artist_id
            left join artists as track_artists on tracks.track_artist_id = track_artists.artist_id
            left join genres on tracks.genre_id = genres.genre_id
            left join composers on tracks.composer_id = composers.composer_id
            left join groupings on tracks.grouping_id = groupings.grouping_id
            left join track_options on tracks.track_id = track_options.track_id
    ";

filteredPlaylistStatement(db: SqliteDB, view: SortedView)
    = SqliteStatement(db,
        if (empty?(view.sort))
            String(playlistQuery)
        else
            printString(playlistQuery, " order by ", view.sort)
    );
overload filteredPlaylistStatement(db: SqliteDB, view: PlaylistView)
    = SqliteStatement(db, playlistQuery + "
            inner join playlist_tracks on tracks.track_id = playlist_tracks.track_id
        where
            playlist_tracks.playlist_id = ?
        order by
            playlist_tracks.position
    ", view.id);
overload filteredPlaylistStatement(db: SqliteDB, view: PlaylistFolderView)
    = SqliteStatement(db, playlistQuery + "
            inner join playlist_tracks on tracks.track_id = playlist_tracks.track_id
            inner join playlists on playlist_tracks.playlist_id = playlists.playlist_id
        where
            playlists.playlist_folder_id = ?
        order by
            playlists.position, playlist_tracks.position
    ", view.id);

refreshPlaylistDataSource(self: PlaylistDataSource) {
    clear(self^.tracks);

    for (row in filteredPlaylistStatement(self^.library^.db, *self^.libraryView))
        push(self^.tracks, rowRecord(row, PlaylistTrack));
}

