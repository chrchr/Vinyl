import cocoa.*;
import cocoa.appkit.*;
import Vinyl.library.*;
import Vinyl.controllers.main.*;
import Vinyl.importers.itunes.*;
import sqlite.*;

overload selector(static #"importItunesLibrary:modalForWindow:modalDelegate:didEndSelector:contextInfo:")
    = Void, NSString, NSWindow, Id, SelectorHandle, RawPointer;
overload selector(static #"cancel:") = Void, Id;
overload selector(static #"setProgressIndicatorValue:") = Void, NSNumber;
overload selector(static #"_importThread:") = Void, Id;
overload selector(static #"reportImportError:") = Void, NSDictionary;

alias ItunesImportErrorNotification = NSString(#"VinylItunesImportErrorNotification");
alias ItunesImportErrorMessageKey = NSString(#"VinylItunesImportErrorMessage");
alias ItunesImportErrorDetailKey = NSString(#"VinylItunesImportErrorDetail");

itunesErrorMessage(x) = Id(#"Importing the iTunes library failed.");
itunesErrorDetail(x) = Id(printString(x));

overload itunesErrorDetail(x: ItunesXMLParserError)
    = Id(printString(
        "The XML parser encountered an error.\nCode: ", x.code,
        "\nDescription: ", x.message,
        "\nLine number: ", x.line,
        "\nColumn: ", x.column,
    ));
overload itunesErrorDetail(x: ItunesInvalidLibraryError)
    = Id(#"The library file appears to be improperly formatted.");
overload itunesErrorDetail(x: SqliteError)
    = Id(printString(
        "There was an error updating the Vinyl library database.\nCode: ", x.code,
        "\nDescription: ", x.message,
    ));

findItunesLibrary() {
    var fm = NSFileManager.defaultManager();
    var itunesLibrary = NSString(#"~/Music/iTunes/iTunes Music Library.xml")
        .stringByExpandingTildeInPath();

    if (fm.isReadableFileAtPath(itunesLibrary))
        return itunesLibrary;
    else
        return nil(NSString);
}

performImportItunesLibrary(self: MainController, itunesLibrary: NSString) {
    if (nil?(itunesLibrary)) {
        NSNotificationCenter.defaultCenter().postNotificationName_object_userInfo(
            ItunesImportErrorNotification,
            self,
            makeNSDictionary(
                ItunesImportErrorMessageKey, #"The iTunes library file could not be found.",
                ItunesImportErrorDetailKey, #"Check that the \"iTunes Music Library.xml\" file is available in in the \"Music/iTunes\" folder under your home folder.",
            ),
        );
    } else {
        var importController = ItunesImportController.alloc().init();

        if (nil?(importController))
            NSNotificationCenter.defaultCenter().postNotificationName_object_userInfo(
                ItunesImportErrorNotification,
                self,
                makeNSDictionary(
                    ItunesImportErrorMessageKey, #"The iTunes importer failed to start.",
                    ItunesImportErrorDetailKey, #"Please report this error.",
                ),
            );
        else
            importController.importItunesLibrary_modalForWindow_modalDelegate_didEndSelector_contextInfo(
                itunesLibrary,
                self^.mainWindow,
                self,
                selectorHandle(#"_itunesSheetDidEnd:returnCode:contextInfo:"),
                RawPointer(importController)
            );
    }
}

// NB: must send messages to main thread!
private updateProgressCallback(self, stage, distance, goal) {
    alias READ_STAGE_LENGTH = 80.0;
    alias MERGE_STAGE_LENGTH = 20.0;

    if (stage != self^.stage) {
        var message = StringConstant();
        switch (stage) {
        case ReadItunesLibrary:
            message = "Reading iTunes library...";
            break;
        case MergeVinylLibrary:
            message = "Merging with Vinyl library...";
            break;
        }
        self^.statusField.performSelectorOnMainThread_withObject_waitUntilDone(
            selectorHandle(#"setStringValue:"),
            NSString(message),
            false
        );
        self^.stage = stage;
    }
            
    var progress = 0.0;
    switch (stage) {
    case ReadItunesLibrary:
        progress = READ_STAGE_LENGTH * (Double(distance)/Double(goal));
        break;
    case MergeVinylLibrary:
        progress = READ_STAGE_LENGTH + MERGE_STAGE_LENGTH * (Double(distance)/Double(goal));
        break;
    }

    self.performSelectorOnMainThread_withObject_waitUntilDone(
        selectorHandle(#"setProgressIndicatorValue:"),
        progress,
        false,
    );

    return not self^.cancelled;
}

record ItunesImportController = newClass(#VinylItunesImportController, NSObject,
    InstanceVars(
        ...IBOutlets(
            sheet: Retained[NSPanel],
            statusField: NSTextField,
            progressIndicator: NSProgressIndicator,
        ),
        stage: ItunesParseStage,
        cancelled: Bool,
    ),
    ClassMethods(),
    InstanceMethods(
        (#"init", (self) => initObjectWith(self, #"init", self => {
            self^.stage = MergeVinylLibrary;
            self^.cancelled = false;

            if (not NSBundle.loadNibNamed_owner(#"ItunesImportController", self)) {
                self.release();
                return nil(ItunesImportController);
            } else
                return self;
        })),

        ...IBActions(
            (#"cancel:", (self, sender) => {
                self^.cancelled = true;
            }),
        ),

        (#"importItunesLibrary:modalForWindow:modalDelegate:didEndSelector:contextInfo:",
            (self, filename, window, delegate, selector, context) => {
                NSApp.beginSheet_modalForWindow_modalDelegate_didEndSelector_contextInfo(
                    self^.sheet, window, delegate, selector, context
                );

                NSThread.detachNewThreadSelector_toTarget_withObject(
                    selectorHandle(#"_importThread:"), self, filename
                );
            }
        ),

        (#"_importThread:", (self, filename) => {
            withAutoreleasePool(() => {
                var library = Library();

                try {
                    importItunes(library, String(filename),
                        (stage, distance, goal) =>
                            updateProgressCallback(self, stage, distance, goal)
                    );
                } catch (cancel: ItunesImportCancelled) {
                    // do nothing
                } catch (ex) {
                    NSApp.performSelectorOnMainThread_withObject_waitUntilDone(
                        selectorHandle(#"endSheet:"),
                        self^.sheet,
                        true,
                    );
                    self.performSelectorOnMainThread_withObject_waitUntilDone(
                        selectorHandle(#"reportImportError:"),
                        makeNSDictionary(
                            ItunesImportErrorMessageKey, itunesErrorMessage(*ex),
                            ItunesImportErrorDetailKey,  itunesErrorDetail(*ex),
                        ),
                        false,
                    );
                    return;
                }

                NSApp.performSelectorOnMainThread_withObject_waitUntilDone(
                    selectorHandle(#"endSheet:"),
                    self^.sheet,
                    false
                );
            });
        }),

        (#"setProgressIndicatorValue:", (self, value) => {
            self^.progressIndicator.setDoubleValue(value.doubleValue());
        }),
        (#"reportImportError:", (self, info) => {
            NSNotificationCenter.defaultCenter().postNotificationName_object_userInfo(
                ItunesImportErrorNotification, self, info
            );
        }),

        DeallocInstanceMethod(),
    ),
);
